package tech.b180.cordaptor.rest

import org.koin.core.inject
import tech.b180.cordaptor.kernel.CordaptorComponent
import tech.b180.cordaptor.kernel.getAll
import tech.b180.cordaptor.kernel.loggerFor
import tech.b180.cordaptor.shaded.javax.json.Json
import tech.b180.cordaptor.shaded.javax.json.JsonObject
import java.net.URL
import javax.servlet.http.HttpServletRequest
import javax.servlet.http.HttpServletResponse

/**
 * Jetty context handler responsible for generating an OpenAPI definition file
 * based on the catalog of the underlying node.
 */
class APISpecificationEndpointHandler(
    contextPath: String,
    connectorConfiguration: JettyConnectorConfiguration
) : AbstractEndpointHandler<OpenAPI>(
    responseType = OpenAPI::class.java,
    mappingParameters = ContextMappingParameters(contextPath, true)
), CordaptorComponent {

  private val serializationFactory: SerializationFactory by inject()

  override fun canHandle(request: HttpServletRequest): Boolean = request.method == "GET"

  /** Object representing OpenAPI schema */
  private val apiSpecification by lazy(LazyThreadSafetyMode.SYNCHRONIZED) {
    // this is generated lazily upon first request because it may never be requested,
    // but also to allow all dynamic endpoints to be registered in respective container lifecycle callbacks

    val allProviders = getAll<EndpointProvider>()
    val allQueries = allProviders.flatMap { it.queryEndpoints } + getAll<QueryEndpoint<*>>()
    val allOperations = allProviders.flatMap { it.operationEndpoints } + getAll<OperationEndpoint<*, *>>()

    OpenAPISpecificationBuilder(serializationFactory)
        .withInfo(OpenAPI.Info(title = "Cordaptor API", version = "autogenerated"))
        .withServer(OpenAPI.Server(url = URL(connectorConfiguration.baseUrl)))
        .withQueryEndpoints(allQueries)
        .withOperationEndpoints(allOperations)
        .buildSpec()
  }

  override fun doHandle(request: HttpServletRequest, response: HttpServletResponse) {
    response.status = HttpServletResponse.SC_OK
    response.contentType = JSON_CONTENT_TYPE

    Json.createGenerator(response.writer)
        .writeSerializedObject(responseSerializer, apiSpecification)
        .flush()
  }
}

/**
 * Builder object to construct OpenAPI specification.
 */
data class OpenAPISpecificationBuilder(
    val serializationFactory: SerializationFactory,
    val info: OpenAPI.Info? = null,
    val servers: List<OpenAPI.Server> = emptyList(),
    val queryEndpoints: List<QueryEndpoint<*>> = emptyList(),
    val operationEndpoint: List<OperationEndpoint<*, *>> = emptyList()
) {

  fun withInfo(info: OpenAPI.Info) = copy(info = info)

  fun withServer(server: OpenAPI.Server) = copy(servers = servers + server)

  fun withQueryEndpoints(endpoints: List<QueryEndpoint<*>>) = copy(queryEndpoints = endpoints)

  fun withOperationEndpoints(endpoints: List<OperationEndpoint<*, *>>) = copy(operationEndpoint = endpoints)

  fun buildSpec(): OpenAPI {
    require(info != null)

    val generator = CollectingJsonSchemaGenerator(OpenAPI.COMPONENTS_SCHEMA_PREFIX, serializationFactory)
    val paths = (queryEndpoints + operationEndpoint).map { it.resourceSpecification }
        .map { it.resourcePath to it.generatePathInfoSpecification(generator) }
        .groupBy(keySelector = { it.first }, valueTransform = { it.second })
        .mapValues { (_, items) -> items.reduce(OpenAPI.PathItem::mergeOperationsWith) }

    return OpenAPI(info = info!!, servers = servers, paths = paths,
        components = OpenAPI.Components(generator.collectedSchemas))
  }
}

/**
 * Generator for nested JSON Schema objects to be passed into [JsonSerializer.generateSchema] method
 * when creating OpenAPI specification document. The implementation contains logic that understands
 * what types should be declared in the components section of the OpenAPI document, and emits
 * references instead of actual JSON Schema objects where this happens. As the object works through the
 * nested objects it also collects encountered reusable types, and then makes them available.
 *
 * Note that this is a non-threadsafe single-use object.
 */
class CollectingJsonSchemaGenerator(
    private val referencePathPrefix: String,
    private val serializationFactory: SerializationFactory
) : JsonSchemaGenerator {

  // key value is used only for generating error message for type names clash
  data class NamedSchemaObject(val name: String, val key: SerializerKey, val schema: JsonObject)

  companion object {
    val logger = loggerFor<CollectingJsonSchemaGenerator>()
  }

  private val inlineSchemas = mutableMapOf<SerializerKey, JsonObject>()
  private val collectedNamedSchemas = mutableMapOf<SerializerKey, NamedSchemaObject>()

  val collectedSchemas: Map<String, JsonObject>
    get() = collectedNamedSchemas.values
        .groupBy(NamedSchemaObject::name)
        .mapValues { (_, v) ->
          if (v.size > 1) {
            logger.error("Multiple schema objects are mapped to the same type name: ${v.map { it.key }}")
          }
          v.first().schema
        }

  override fun generateSchema(key: SerializerKey): JsonObject {
    return inlineSchemas.getOrPut(key) {
      val serializer = serializationFactory.getSerializer(key)
      if (serializer is StandaloneTypeSerializer) {
        // this is a standalone type, so its schema will be collected into a named section
        // and instead a reference will generated for using inline where required
        collectedNamedSchemas[key] = NamedSchemaObject(
            serializer.schemaTypeName, key, serializer.generateSchema(this))

        createReference(serializer.schemaTypeName)
      } else {
        // this is a simple type (e.g. collection), so its schema will be generated inline
        serializer.generateSchema(this)
      }
    }
  }

  /** [https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#referenceObject] */
  private fun createReference(schemaTypeName: String): JsonObject {
    return Json.createObjectBuilder()
        .add("\$ref", referencePathPrefix + schemaTypeName)
        .build()
  }
}
